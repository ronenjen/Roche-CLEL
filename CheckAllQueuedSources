#r Roche.LAMA1.dll

/*
Script written by Ronen Peleg (ronenpeleg@biosero.com)

Description:
followup  script to determine the the current state of sources processed for REMP or crash sources.
The script is designed to run on a loop (with a slight delay) to always capture the correct current state
*/

using Biosero.DataServices.Client;
using Biosero.Orchestrator.WorkflowService;
using Newtonsoft.Json;
using System;
using System.Threading;
using System.Threading.Tasks;
using System.Collections.Generic;
using System.Text;
using System.Linq;
using Roche.LAMA1;
using Roche.LAMA1.Models;
using Roche.LAMA1.MosaicTypes;
using Biosero.DataServices.RestClient;
using Biosero.DataModels.Events;
using Biosero.DataModels.Ordering;
using Biosero.DataModels.Clients;
using Biosero.DataModels.Resources;
using System.Security.Cryptography;
using System.Collections;


namespace Biosero.Scripting
{
    public class CheckAllQueuedSources
    {
        public async Task RunAsync(DataServicesClient client, WorkflowContext context, CancellationToken cancellationToken)
        {
            // Retrieve order ID ran
            string RequestedOrder = context.GetGlobalVariableValue<string>("Input.OrderId");


            // connnect to the DS server, declare query, assecssioning and event clients for the URL
            string API_BASE_URL = "http://192.168.14.10:8105/api/v2.0/";

            IQueryClient _queryClient = new QueryClient(API_BASE_URL);
            IAccessioningClient _accessioningClient = new AccessioningClient(API_BASE_URL);
            IEventClient _eventClient = new EventClient(API_BASE_URL);


            IdentityHelper _identityHelper;


            //Build out and register the root identities (i.e Mosaic Job) if they do not exist
            _identityHelper = new IdentityHelper(_queryClient, _accessioningClient, _eventClient);
            _identityHelper.BuildBaseIdentities();


            //Get all the sources associated with this order
            var sources = _identityHelper.GetSources(RequestedOrder).ToList();

            //Get all the destinations associated with this order
            var destinations = _identityHelper.GetDestinations(RequestedOrder).ToList();
            //Get all the jobs
            var jobs = _identityHelper.GetJobs(RequestedOrder).ToList();


            // Various lists used throughout processing to collect related data for the order and job
            List<string> AllSourcesForOrder = new List<string>();
            List<string> QueuedSourcesForOrder = new List<string>();
            List<string> ReadySourcesForOrder = new List<string>();
            List<string> CancelledSourcesForOrder = new List<string>();
            List<string> ProcessedSourcesForOrder = new List<string>();

            List<string> AllCrashPlatesForOrder = new List<string>();
            List<string> QueuedCrashPlatesForOrder = new List<string>();
            List<string> ReadyCrashPlatesForOrder = new List<string>();
            List<string> CancelledCrashPlatesForOrder = new List<string>();
            List<string> ProcessedCrashPlatesForOrder = new List<string>();


            //Loop through all destination identities for the order
            foreach (var dest in destinations)
            {
                string DestinationID = dest.Identifier;
                string DestinationyName = dest.Name;
                string DestinationType = dest.TypeIdentifier;
                // int DestinationDescription = dest.JobId;
                string DestinationState = dest.Status.ToString();
                string DestinationOperationType = dest.OperationType.ToString();
                string DestinationSampleTransfers = dest.SampleTransfers;
                string DestinationParent = dest.ParentIdentifier != null ? dest.ParentIdentifier.ToString() : null;
                string DestSibling = dest.SiblingIdentifier?.ToString() ?? "";

                //string DestinationParent;
                // string DestSibling = "";


                if (dest != null && dest.SiblingIdentifier != null)
                {
                    DestSibling = dest.SiblingIdentifier.ToString();
                    // Continue with your logic
                }
                else
                {
                    // Handle the case where dest or SiblingIdentifier is null
                    // For example, set DestSibling to a default value or handle the error
                    DestSibling = string.Empty; // or any default value you deem appropriate
                }



                if (dest.ParentIdentifier != null)
                {
                    DestinationParent = dest.ParentIdentifier.ToString();
                }
                else
                {
                    DestinationParent = string.Empty;
                }


                if (DestinationOperationType == "CherryPick")
                {

                    //////////
                    /// use the DestinationSampleTransfers to determine all required sources for the destination. 
                    /// Add to alist of all sources and another list of all queued sources.
                    /// Lists will be used to compare job required vs work done....
                    /// /////////////

                    string[] lines = DestinationSampleTransfers.Split(new[] { "\r\n" }, StringSplitOptions.RemoveEmptyEntries);
                    var firstValues = lines.Select(line => line.Split(',')[0]);
                    foreach (var value in firstValues)
                    {
                        // If unknown source, add to total list of order CP sources and queued list of sources
                        if (!AllSourcesForOrder.Contains(value))
                        {
                            AllSourcesForOrder.Add(value);
                            QueuedSourcesForOrder.Add(value);
                        }
                    }

                }

                else if ((DestinationOperationType == "Replicate") && (DestinationParent == ""))
                {

                    //////////
                    /// use the DestinationSampleTransfers to determine all required crash plates for the destination. 
                    /// Add to alist of all sources and another list of all queued crash sources.
                    /// Lists will be used to compare job required vs work done....
                    /// /////////////
                    /// 
                    string[] Crashlines = DestinationSampleTransfers.Split(new[] { "\r\n" }, StringSplitOptions.RemoveEmptyEntries);
                    var firstCrashValues = Crashlines.Select(line => line.Split(',')[0]);



                    //get the source name for the current destination identity
                    var a = sources
                    .Where(a => a.Identifier == DestSibling)
                    .FirstOrDefault();

                    string SiblingName = a.Name;


                    // get the erequired source labware type
                    string SourceLabwareType = a.CommonName.ToString();

                    //Add labware type to the DS variable called "CrashLabwareType"
                    await context.AddOrUpdateGlobalVariableAsync("CrashLabwareType", SourceLabwareType);

                    // If unknown source, add to total list of order crash plates and queued list of crash plates
                    if (!AllCrashPlatesForOrder.Contains(SiblingName))
                    {
                        AllCrashPlatesForOrder.Add(SiblingName);
                        QueuedCrashPlatesForOrder.Add(SiblingName);
                    }

                }

            }

            //scroll through all sources for the order
            foreach (var source in sources)
            {
                string SourceIdentityID = source.Identifier;
                string SourceIdentityName = source.Name;
                string SourceIdentityType = source.TypeIdentifier;
                string SourceIndentityState = source.Status.ToString();


                Serilog.Log.Information("Source Name= {SourceIdentityName} Source State= {SourceIndentityState}", SourceIdentityName.ToString(), SourceIndentityState.ToString());

                //If found source is part of the queued sources list from top section of script, continue processing
                if (QueuedSourcesForOrder.Contains(SourceIdentityName))
                {
                    //If the source is either of state "Ready" or state "Cancelled" - add to the relevant list of sources
                    // Check for cancelled CP sources and add to the relevant lists
                    if ((!CancelledSourcesForOrder.Contains(SourceIdentityName)) && (SourceIndentityState == "Cancelled"))
                    {
                        CancelledSourcesForOrder.Add((SourceIdentityName));
                    }
                    // Check for ready CP sources and add to the relevant lists
                    else if ((!ReadySourcesForOrder.Contains(SourceIdentityName)) && (SourceIndentityState == "Ready"))
                    {
                        ReadySourcesForOrder.Add((SourceIdentityName));
                    }
                }

                //If found crash plate is part of the queued crash pate list from top section of script, continue processing
                if (QueuedCrashPlatesForOrder.Contains(SourceIdentityName))
                {
                    //If the crash plate is either of state "Ready" or state "Cancelled" - add to the relevant list of crash plates
                    // Check for cancelled CP crash plates and add to the relevant lists
                    if ((!CancelledCrashPlatesForOrder.Contains(SourceIdentityName)) && (SourceIndentityState == "Cancelled"))
                    {
                        CancelledCrashPlatesForOrder.Add((SourceIdentityName));
                    }
                    // Check for ready CP crash plates and add to the relevant lists
                    else if ((!ReadyCrashPlatesForOrder.Contains(SourceIdentityName)) && (SourceIndentityState == "Ready"))
                    {
                        ReadyCrashPlatesForOrder.Add((SourceIdentityName));
                    }
                }

            }


            // Format a string version of all created lists
            string AllQueuedSources = string.Join(",", QueuedSourcesForOrder);
            string AllReadyCrashPlates = string.Join(",", ReadyCrashPlatesForOrder);
            string AllReadySources = string.Join(",", ReadySourcesForOrder);
            string AllQueuedCrashPlates = string.Join(",", QueuedCrashPlatesForOrder);
            string AllCancelledSources = string.Join(",", CancelledSourcesForOrder);
            string AllCancelledCrashPlates = string.Join(",", CancelledCrashPlatesForOrder);
            string AllCrashPlates = string.Join(",", AllCrashPlatesForOrder);
            string AllSources = string.Join(",", AllSourcesForOrder);


            // Count members for each list and save to a variable
            int TotalQueuedsources = QueuedSourcesForOrder.Count;
            int TotalQueuedCrashPlates = QueuedCrashPlatesForOrder.Count;
            int TotalReadySources = ReadySourcesForOrder.Count;
            int TotalReadyCrashPlates = ReadyCrashPlatesForOrder.Count;
            int TotalCancelledSources = CancelledSourcesForOrder.Count;
            int TotalCancelledCrashPlates = CancelledCrashPlatesForOrder.Count;
            int Totalsources = AllSourcesForOrder.Count;
            int TotalCrashPlates = AllCrashPlatesForOrder.Count;


            Serilog.Log.Information("Following sources are queued: {AllQueuedSources}", AllQueuedSources.ToString());
            Serilog.Log.Information("Following sources have a READY state: {AllReadySources}", AllReadySources.ToString());
            Serilog.Log.Information("Following sources have a CANCELLED state: {AllCancelledSources}", AllCancelledSources.ToString());

            Serilog.Log.Information("Following crash plates are queued: {AllQueuedCrashPlates}", AllQueuedCrashPlates.ToString());
            Serilog.Log.Information("Following crash plates have a READY state: {AllReadyCrashPlates}", AllReadyCrashPlates.ToString());
            Serilog.Log.Information("Following crash plates have a CANCELLED state: {AllCancelledCrashPlates}", AllCancelledCrashPlates.ToString());


            //add two ranges to a general "processed" list
            ProcessedSourcesForOrder.AddRange(CancelledSourcesForOrder);
            ProcessedSourcesForOrder.AddRange(ReadySourcesForOrder);

            //add two ranges to a general crash plates "processed" list
            ProcessedCrashPlatesForOrder.AddRange(CancelledCrashPlatesForOrder);
            ProcessedCrashPlatesForOrder.AddRange(ReadyCrashPlatesForOrder);

            // format a string containing all processed sources and crash plates
            string AllProcessedSources = string.Join(",", ProcessedSourcesForOrder);
            string AllProcessedCrashPlates = string.Join(",", ProcessedCrashPlatesForOrder);

            // format an int variable with the total processed sources and total processed crash plates
            int TotalProcessedSources = ProcessedSourcesForOrder.Count;
            int TotalProcessedCrashPlates = ProcessedCrashPlatesForOrder.Count;


            // add total queued and total processed sources to the relavant DS variables
            await context.AddOrUpdateGlobalVariableAsync("Total Sources", TotalQueuedsources);
            await context.AddOrUpdateGlobalVariableAsync("Total Processed Sources", TotalProcessedSources);

            // add total queued and total processed crash plates to the relavant DS variables
            await context.AddOrUpdateGlobalVariableAsync("Total Crash Plates", TotalQueuedCrashPlates);
            await context.AddOrUpdateGlobalVariableAsync("Total Processed Crash Plates", TotalProcessedCrashPlates);

            // add details of all proceessed sources to the relavant DS variable
            if (TotalReadySources > 0)
            {
                await context.AddOrUpdateGlobalVariableAsync("IOC Processed Racks", AllReadySources);
            }

            // add details of all cancelled sources to the relavant DS variable
            if (TotalCancelledSources > 0)
            {
                await context.AddOrUpdateGlobalVariableAsync("IOC Cancelled Racks", AllCancelledSources);
            }


            // add details of all proceessed crash plates to the relavant DS variable
            if (TotalReadyCrashPlates > 0)
            {
                await context.AddOrUpdateGlobalVariableAsync("IOC Processed Crash Plates", AllReadyCrashPlates);
            }

            // add details of all cancelled crash plates to the relavant DS variable
            if (TotalCancelledCrashPlates > 0)
            {
                await context.AddOrUpdateGlobalVariableAsync("IOC Cancelled Crash Plates", AllCancelledCrashPlates);
            }


            Serilog.Log.Information("All sources for the order= {AllSources} Total sources found for the order {Totalsources}", AllSources.ToString(), Totalsources.ToString());
            Serilog.Log.Information("All queued sources for the order= {AllQueuedSources} Total Queued sources for the order {TotalQueuedsources}", AllQueuedSources.ToString(), TotalQueuedsources.ToString());
            Serilog.Log.Information("All Processed sources for the order= {AllProcessedSources} Total processed sources for the order{TotalProcessedSources}", AllProcessedSources.ToString(), TotalProcessedSources.ToString());
            Serilog.Log.Information("====$$$$$$$====");
            Serilog.Log.Information("All crash plates for the order= {AllCrashPlates} Total crash plates for the order {TotalCrashPlates}", AllCrashPlates.ToString(), TotalCrashPlates.ToString());
            Serilog.Log.Information("all queued crash plates for the order= {AllQueuedCrashPlates} Total Queued crash plates for the order{TotalQueuedCrashPlates}", AllQueuedCrashPlates.ToString(), TotalQueuedCrashPlates.ToString());
            Serilog.Log.Information("All processed crash plates for the order= {AllProcessedCrashPlates} Total processed crash plates for the order {TotalProcessedCrashPlates}", AllProcessedCrashPlates.ToString(), TotalProcessedCrashPlates.ToString());


        }


    }
}
