#r Roche.LAMA1.dll

using Biosero.DataServices.Client;
using Biosero.Orchestrator.WorkflowService;
using Newtonsoft.Json;
using System;
using System.Threading;
using System.Threading.Tasks;
using System.Collections.Generic;
using System.Text;
using System.Linq;
using Roche.LAMA1;
using Roche.LAMA1.Models;
using Roche.LAMA1.MosaicTypes;
using Biosero.DataServices.RestClient;
using Biosero.DataModels.Events;
using Biosero.DataModels.Ordering;
using Biosero.DataModels.Clients;
using Biosero.DataModels.Resources;
using System.Security.Cryptography;
using System.Collections;


namespace Biosero.Scripting
{
    public class FindCurrentREMPRackStatus
    {
        public async Task RunAsync(DataServicesClient client, WorkflowContext context, CancellationToken cancellationToken)
        {

            string QueuedSources = context.GetGlobalVariableValue<string>("Queued Sources");
            string RequestedOrder = context.GetGlobalVariableValue<string>("Input.OrderId");
            string firstorderId = RequestedOrder;
            await context.AddOrUpdateGlobalVariableAsync("Skip REMP Preparatin", false);

            string SkipREMPPrep = "false";
            var orders = await client.GetOrdersAsync();

            orders = orders
                .Where(x => x.StatusDetails == "Running..." && x.TemplateName == "State Machine V1.1")
                .OrderBy(x => x.CreationTime)  // Replace OrderNumber with the actual numeric property
                .ToArray();

            var firstOrder = orders.FirstOrDefault();

            if (firstOrder != null)
            {

                var firstorderIdentifier = firstOrder.InputParameters;


                var d = firstorderIdentifier
                .Where(x => x.Name == "OrderId")
                .FirstOrDefault();


                if (d != null)
                {
                    firstorderId = d.Value.ToString();
                }
            }
            else
            {
                firstorderId = RequestedOrder;

            }


            Console.WriteLine($"the first order is {firstorderId}" + Environment.NewLine); 


          //  string API_BASE_URL = "http://192.168.14.10:8105/api/v2.0/";
            string API_BASE_URL =  context.GetGlobalVariableValue<string>("_url"); // "http://1 92.168.14.10:8105/api/v2.0/";
            
            
            
            IQueryClient _queryClient = new QueryClient(API_BASE_URL);
            IAccessioningClient _accessioningClient = new AccessioningClient(API_BASE_URL);
            IEventClient _eventClient = new EventClient(API_BASE_URL);


            IdentityHelper _identityHelper;


            //Build out and register the root identities (i.e Mosaic Job) if they do not exist
            _identityHelper = new IdentityHelper(_queryClient, _accessioningClient, _eventClient);
            _identityHelper.BuildBaseIdentities();


            //Get all the sources associated with this order
            var sources = _identityHelper.GetSources(RequestedOrder).ToList();


            var c = sources
            .Where(x => x.Name == QueuedSources)
            .FirstOrDefault();

            if (c != null)
            {
                Console.WriteLine($"not null" + Environment.NewLine);
            }
            else
            {

                Console.WriteLine($"null" + Environment.NewLine);
            }
            string CurrentSourceName = c.Name;
            string CurrentSourceStatus = c.Status.ToString();
            int CurrentJobID = c.JobId; // Identity Job as string

            //  Console.WriteLine($" Status for rack  {CurrentSourceName}  is {CurrentSourceStatus} for Order {RequestedOrder}" + Environment.NewLine);


            foreach (var order in orders)
            {
                string OrderId = order.Identifier;


                // Assuming order.InputParameters is already a collection of Parameters
                foreach (var param in order.InputParameters)
                {
                    if (param.Name == "OrderId")
                    {
                        string orderIdValue = param.Value.ToString();

                        var innersources = _identityHelper.GetSources(orderIdValue).ToList();
                        foreach (var innersource in innersources)
                        {
                            int identityJobID = innersource.JobId; // Identity Job as string
                            string SourceIdentityID = innersource.Identifier;
                            string SourceIdentityName = innersource.Name;
                            string SourceIdentityType = innersource.TypeIdentifier;
                            string SourceIndentityState = innersource.Status.ToString();
                            
                            // If we have the same REMP rack for another running order - 
                            if ((SourceIdentityName == CurrentSourceName) && (orderIdValue != RequestedOrder) &&  (CurrentSourceStatus=="Pending") && (firstorderId != RequestedOrder))
                            {
                                Console.WriteLine($" Status for rack  {SourceIdentityName}  is {SourceIndentityState} for Order {orderIdValue}" + Environment.NewLine);

                                c.Properties.SetValue("Status", SourceIndentityState);
                                _identityHelper.Register(c, CurrentJobID, RequestedOrder);

                                Console.WriteLine($" Status for rack  {SourceIdentityName} was changed from {CurrentSourceStatus} to {SourceIndentityState} for order {RequestedOrder}" + Environment.NewLine);


                                SkipREMPPrep = "true";
                                await context.AddOrUpdateGlobalVariableAsync("Skip REMP Preparatin", true);

                            }

                        }
                    }
                }
            }

           if ( SkipREMPPrep=="false")
            {
                Console.WriteLine($" Not skipping REMP prep for order {RequestedOrder}" + Environment.NewLine);
            }
            else
            {
                Console.WriteLine($" skipping REMP prep for order {RequestedOrder}" + Environment.NewLine);
            }

        }

    }
}


