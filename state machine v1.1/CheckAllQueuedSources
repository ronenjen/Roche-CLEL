#r Roche.LAMA1.dll

/*
Script written by Ronen Peleg (ronenpeleg@biosero.com)

Description:
followup  script to determine the the current state of sources processed for REMP or crash sources.
The script is designed to run on a loop (with a slight delay) to always capture the correct current state
*/

using Biosero.DataServices.Client;
using Biosero.Orchestrator.WorkflowService;
using Newtonsoft.Json;
using System;
using System.Threading;
using System.Threading.Tasks;
using System.Collections.Generic;
using System.Text;
using System.Linq;
using Roche.LAMA1;
using Roche.LAMA1.Models;
using Roche.LAMA1.MosaicTypes;
using Biosero.DataServices.RestClient;
using Biosero.DataModels.Events;
using Biosero.DataModels.Ordering;
using Biosero.DataModels.Clients;
using Biosero.DataModels.Resources;
using System.Security.Cryptography;
using System.Collections;

namespace Biosero.Scripting
{
    public class CheckAllQueuedSources
    {
        public async Task RunAsync(DataServicesClient client, WorkflowContext context, CancellationToken cancellationToken)
        {
            // Retrieve order ID ran
            string RequestedOrder = context.GetGlobalVariableValue<string>("Input.OrderId");
            string RacksOnCP = context.GetGlobalVariableValue<string>("CP On Racks");

            Console.WriteLine($"**VSVSVS***  These are the rack currently on CP VS {RacksOnCP}  " + Environment.NewLine);

            // connnect to the DS server, declare query, assecssioning and event clients for the URL
           // string API_BASE_URL = "http://192.168.14.10:8105/api/v2.0/";
            string API_BASE_URL =  context.GetGlobalVariableValue<string>("_url"); // "http://1 92.168.14.10:8105/api/v2.0/";

            IQueryClient _queryClient = new QueryClient(API_BASE_URL);
            IAccessioningClient _accessioningClient = new AccessioningClient(API_BASE_URL);
            IEventClient _eventClient = new EventClient(API_BASE_URL);

            IdentityHelper _identityHelper;

            //Build out and register the root identities (i.e Mosaic Job) if they do not exist
            _identityHelper = new IdentityHelper(_queryClient, _accessioningClient, _eventClient);
            _identityHelper.BuildBaseIdentities();


            //Get all the sources associated with this order
            var sources = _identityHelper.GetSources(RequestedOrder).ToList();

            //Get all the destinations associated with this order
            var destinations = _identityHelper.GetDestinations(RequestedOrder).ToList();
            //Get all the jobs
            var jobs = _identityHelper.GetJobs(RequestedOrder).ToList();


            // Various lists used throughout processing to collect related data for the order and job
            List<string> AllSourcesForOrder = new List<string>();
            List<string> QueuedSourcesForOrder = new List<string>();
            List<string> ReadySourcesForOrder = new List<string>();
            List<string> CancelledSourcesForOrder = new List<string>();
            List<string> ProcessedSourcesForOrder = new List<string>();
            List<string> DuplicateSourcesForOrder = new List<string>();
            

            List<string> AllCrashPlatesForOrder = new List<string>();
            List<string> QueuedCrashPlatesForOrder = new List<string>();
            List<string> ReadyCrashPlatesForOrder = new List<string>();
            List<string> CancelledCrashPlatesForOrder = new List<string>();
            List<string> ProcessedCrashPlatesForOrder = new List<string>();


            //Loop through all destination identities for the order
            foreach (var dest in destinations)
            {
                string DestinationID = dest.Identifier;
                string DestinationyName = dest.Name;
                string DestinationType = dest.TypeIdentifier;
                // int DestinationDescription = dest.JobId;
                string DestinationState = dest.Status.ToString();
                string DestinationOperationType = dest.OperationType.ToString();
                string DestinationSampleTransfers = dest.SampleTransfers;
                string DestinationParent = dest.ParentIdentifier != null ? dest.ParentIdentifier.ToString() : null;
                string DestSibling = dest.SiblingIdentifier?.ToString() ?? "";

                //string DestinationParent;
                // string DestSibling = "";


                if (dest != null && dest.SiblingIdentifier != null)
                {
                    DestSibling = dest.SiblingIdentifier.ToString();
                    // Continue with your logic
                }
                else
                {
                    // Handle the case where dest or SiblingIdentifier is null
                    // For example, set DestSibling to a default value or handle the error
                    DestSibling = string.Empty; // or any default value you deem appropriate
                }

                if (dest.ParentIdentifier != null)
                {
                    DestinationParent = dest.ParentIdentifier.ToString();
                }
                else
                {
                    DestinationParent = string.Empty;
                }


                if (DestinationOperationType == "CherryPick")
                {

                    //////////
                    /// use the DestinationSampleTransfers to determine all required sources for the destination. 
                    /// Add to a list of all sources and another list of all queued sources.
                    /// Lists will be used to compare job required vs work done....
                    /// /////////////

                    string[] lines = DestinationSampleTransfers.Split(new[] { "\r\n" }, StringSplitOptions.RemoveEmptyEntries);
                    var firstValues = lines.Select(line => line.Split(',')[0]);
                    foreach (var value in firstValues)
                    {
                        // If unknown source, add to total list of order CP sources and queued list of sources
                        // don't add rack if it is found using script "Get CP REMP Sources In Virtual Storage" through variable RacksOnCP

                        var b = sources
                        .Where(a => a.Name == value)
                        .FirstOrDefault();

                        string CurrentStatus = b.Status.ToString();


                        Console.WriteLine($"******* current state under CheckAllQueuedSources - {value}, the state is {CurrentStatus} all for order id: {RequestedOrder} " + Environment.NewLine);

                        if (!AllSourcesForOrder.Contains(value))
                        {
                        AllSourcesForOrder.Add(value);
                        }


                        if ((!QueuedSourcesForOrder.Contains(value)) && (!RacksOnCP.Contains(value)) && (CurrentStatus=="Ready"))
                        {
                            Console.WriteLine($"******* {value} added to all sources and queued sources for order {RequestedOrder} " + Environment.NewLine);

                            
                            QueuedSourcesForOrder.Add(value);
                        }
                        else if ((!DuplicateSourcesForOrder.Contains(value)) )
                        {
                            //get all running orders

                            var orders = await client.GetOrdersAsync();

                            orders = orders.Where(x => x.StatusDetails == "Running..." && x.TemplateName == "State Machine V1.1").ToArray();

                            foreach (var order in orders)
                            {
                                string OrderId = order.Identifier;

                                // Assuming order.InputParameters is already a collection of Parameters
                                foreach (var param in order.InputParameters)
                                {
                                    if (param.Name == "OrderId")
                                    {
                                        string orderIdValue = param.Value.ToString();

                                        var innersources = _identityHelper.GetSources(orderIdValue).ToList();
                                        foreach (var innersource in innersources)
                                        {
                                            int DuplicateidentityJobID = innersource.JobId; // Identity Job as string
                                            string DuplicateSourceIdentityID = innersource.Identifier;
                                            string DuplicateSourceIdentityName = innersource.Name;
                                            string DuplicateSourceIdentityType = innersource.TypeIdentifier;
                                            string DuplicateSourceIndentityState = innersource.Status.ToString();

                                            // If we have the same REMP rack for another running order - 
                                            if ((value == DuplicateSourceIdentityName) && (orderIdValue != RequestedOrder))
                                            {
                                                Console.WriteLine($"**VSVSVS***  value added to duplicates {value}  " + Environment.NewLine);
                                                DuplicateSourcesForOrder.Add((value));
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }

                }

                else if ((DestinationOperationType == "Replicate") && (DestinationParent == ""))
                {

                    //////////
                    /// use the DestinationSampleTransfers to determine all required crash plates for the destination. 
                    /// Add to alist of all sources and another list of all queued crash sources.
                    /// Lists will be used to compare job required vs work done....
                    /// /////////////
                    /// 
                    string[] Crashlines = DestinationSampleTransfers.Split(new[] { "\r\n" }, StringSplitOptions.RemoveEmptyEntries);
                    var firstCrashValues = Crashlines.Select(line => line.Split(',')[0]);

                    //get the source name for the current destination identity
                    var a = sources
                    .Where(a => a.Identifier == DestSibling)
                    .FirstOrDefault();

                    string SiblingName = a.Name;

                    // get the erequired source labware type
                    string SourceLabwareType = a.CommonName.ToString();

                    //Add labware type to the DS variable called "CrashLabwareType"
                    await context.AddOrUpdateGlobalVariableAsync("CrashLabwareType", SourceLabwareType);

                    // If unknown source, add to total list of order crash plates and queued list of crash plates
                    if (!AllCrashPlatesForOrder.Contains(SiblingName))
                    {
                        AllCrashPlatesForOrder.Add(SiblingName);
                        QueuedCrashPlatesForOrder.Add(SiblingName);
                    }

                }

            }

            //scroll through all sources for the order
            foreach (var source in sources)
            {
                string SourceIdentityID = source.Identifier;
                string SourceIdentityName = source.Name;
                string SourceIdentityType = source.TypeIdentifier;
                string SourceIndentityState = source.Status.ToString();


                Serilog.Log.Information("Source Name= {SourceIdentityName} Source State= {SourceIndentityState}", SourceIdentityName.ToString(), SourceIndentityState.ToString());

                //If found source is part of the queued sources list from top section of script, continue processing
                if (QueuedSourcesForOrder.Contains(SourceIdentityName))
                {
                    //If the source is either of state "Ready" or state "Cancelled" - add to the relevant list of sources
                    // Check for cancelled CP sources and add to the relevant lists
                    // don't add rack if it is found using script "Get CP REMP Sources In Virtual Storage" through variable RacksOnCP
                    if ((!CancelledSourcesForOrder.Contains(SourceIdentityName)) && (SourceIndentityState == "Cancelled") && (!RacksOnCP.Contains(SourceIdentityName)))
                    {
                        Console.WriteLine($"**VSVSVS***  value added to cancelled {SourceIdentityName}  " + Environment.NewLine);
                        CancelledSourcesForOrder.Add((SourceIdentityName));
                    }
                    // Check for ready CP sources and add to the relevant lists
                    // don't add rack if it is found using script "Get CP REMP Sources In Virtual Storage" through variable RacksOnCP
                    else if ((!ReadySourcesForOrder.Contains(SourceIdentityName)) && (SourceIndentityState == "Ready") && (!RacksOnCP.Contains(SourceIdentityName)))
                    {
                        Console.WriteLine($"**VSVSVS***  value added to ready {SourceIdentityName}  " + Environment.NewLine);
                        ReadySourcesForOrder.Add((SourceIdentityName));
                    }
                    else if ((!DuplicateSourcesForOrder.Contains(SourceIdentityName)) && (SourceIndentityState == "Validating"))
                    {
                        //get all running orders
                        var orders = await client.GetOrdersAsync();

                        orders = orders.Where(x => x.StatusDetails == "Running..." && x.TemplateName == "State Machine V1.1").ToArray();

                        foreach (var order in orders)
                        {
                            string OrderId = order.Identifier;

                            // Assuming order.InputParameters is already a collection of Parameters
                            foreach (var param in order.InputParameters)
                            {
                                if (param.Name == "OrderId")
                                {
                                    string orderIdValue = param.Value.ToString();

                                    var innersources = _identityHelper.GetSources(orderIdValue).ToList();
                                    foreach (var innersource in innersources)
                                    {
                                        int DuplicateidentityJobID = innersource.JobId; // Identity Job as string
                                        string DuplicateSourceIdentityID = innersource.Identifier;
                                        string DuplicateSourceIdentityName = innersource.Name;
                                        string DuplicateSourceIdentityType = innersource.TypeIdentifier;
                                        string DuplicateSourceIndentityState = innersource.Status.ToString();

                                        // If we have the same REMP rack for another running order - 
                                        if ((SourceIdentityName == DuplicateSourceIdentityName) && (orderIdValue != RequestedOrder) )
                                        {
                                            Console.WriteLine($"**VSVSVS***  value added to duplicates {SourceIdentityName}  " + Environment.NewLine);
                                            DuplicateSourcesForOrder.Add((SourceIdentityName));
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                //If found crash plate is part of the queued crash pate list from top section of script, continue processing
                if (QueuedCrashPlatesForOrder.Contains(SourceIdentityName))
                {
                    //If the crash plate is either of state "Ready" or state "Cancelled" - add to the relevant list of crash plates
                    // Check for cancelled CP crash plates and add to the relevant lists
                    if ((!CancelledCrashPlatesForOrder.Contains(SourceIdentityName)) && (SourceIndentityState == "Cancelled"))
                    {
                        CancelledCrashPlatesForOrder.Add((SourceIdentityName));
                    }
                    // Check for ready CP crash plates and add to the relevant lists
                    else if ((!ReadyCrashPlatesForOrder.Contains(SourceIdentityName)) && (SourceIndentityState == "Ready"))
                    {
                        ReadyCrashPlatesForOrder.Add((SourceIdentityName));
                    }
                }

            }

            // Format a string version of all created lists
            string AllQueuedSources = string.Join(",", QueuedSourcesForOrder);
            string AllReadyCrashPlates = string.Join(",", ReadyCrashPlatesForOrder);
            string AllReadySources = string.Join(",", ReadySourcesForOrder);
            string AllQueuedCrashPlates = string.Join(",", QueuedCrashPlatesForOrder);
            string AllDuplicateSources = string.Join(",", DuplicateSourcesForOrder);
            string AllCancelledSources = string.Join(",", CancelledSourcesForOrder);
            string AllCancelledCrashPlates = string.Join(",", CancelledCrashPlatesForOrder);
            string AllCrashPlates = string.Join(",", AllCrashPlatesForOrder);
            string AllSources = string.Join(",", AllSourcesForOrder);

            // Count members for each list and save to a variable
            int TotalQueuedsources = QueuedSourcesForOrder.Count;
            int TotalQueuedCrashPlates = QueuedCrashPlatesForOrder.Count;
            int TotalReadySources = ReadySourcesForOrder.Count;
            int TotalReadyCrashPlates = ReadyCrashPlatesForOrder.Count;
            int TotalCancelledSources = CancelledSourcesForOrder.Count;
            int TotalCancelledCrashPlates = CancelledCrashPlatesForOrder.Count;
            int Totalsources = AllSourcesForOrder.Count;
            int TotalCrashPlates = AllCrashPlatesForOrder.Count;

            Serilog.Log.Information("Following sources are queued: {AllQueuedSources}", AllQueuedSources.ToString());
            Serilog.Log.Information("Following sources have a READY state: {AllReadySources}", AllReadySources.ToString());
            Serilog.Log.Information("Following sources have a CANCELLED state: {AllCancelledSources}", AllCancelledSources.ToString());

            Serilog.Log.Information("Following crash plates are queued: {AllQueuedCrashPlates}", AllQueuedCrashPlates.ToString());
            Serilog.Log.Information("Following crash plates have a READY state: {AllReadyCrashPlates}", AllReadyCrashPlates.ToString());
            Serilog.Log.Information("Following crash plates have a CANCELLED state: {AllCancelledCrashPlates}", AllCancelledCrashPlates.ToString());


            //add two ranges to a general "processed" list
            ProcessedSourcesForOrder.AddRange(CancelledSourcesForOrder);
            ProcessedSourcesForOrder.AddRange(ReadySourcesForOrder);
            ProcessedSourcesForOrder.AddRange(DuplicateSourcesForOrder);

            //add two ranges to a general crash plates "processed" list
            ProcessedCrashPlatesForOrder.AddRange(CancelledCrashPlatesForOrder);
            ProcessedCrashPlatesForOrder.AddRange(ReadyCrashPlatesForOrder);

            // format a string containing all processed sources and crash plates
            string AllProcessedSources = string.Join(",", ProcessedSourcesForOrder);
            string AllProcessedCrashPlates = string.Join(",", ProcessedCrashPlatesForOrder);

            // format an int variable with the total processed sources and total processed crash plates
            int TotalProcessedSources = ProcessedSourcesForOrder.Count;
            int TotalProcessedCrashPlates = ProcessedCrashPlatesForOrder.Count;


            // add total queued and total processed sources to the relavant DS variables
            await context.AddOrUpdateGlobalVariableAsync("Total Sources", Totalsources);
            await context.AddOrUpdateGlobalVariableAsync("Total Processed Sources", TotalProcessedSources); 

            Console.WriteLine($"***********  total sources for the order= {Totalsources}  " + Environment.NewLine);
            Console.WriteLine($"***********  total processed sources for the order= {TotalProcessedSources}  " + Environment.NewLine);


            // add total queued and total processed crash plates to the relavant DS variables
            await context.AddOrUpdateGlobalVariableAsync("Total Crash Plates", TotalQueuedCrashPlates);
            await context.AddOrUpdateGlobalVariableAsync("Total Processed Crash Plates", TotalProcessedCrashPlates);

            // add details of all proceessed sources to the relavant DS variable
            if (TotalProcessedSources > 0)
            {
                await context.AddOrUpdateGlobalVariableAsync("IOC Processed Racks", AllProcessedSources);
            }

            // add details of all cancelled sources to the relavant DS variable
            if (TotalCancelledSources > 0)
            {
                await context.AddOrUpdateGlobalVariableAsync("IOC Cancelled Racks", AllCancelledSources);
            }

            // add details of all proceessed crash plates to the relavant DS variable
            if (TotalReadyCrashPlates > 0)
            {
                await context.AddOrUpdateGlobalVariableAsync("IOC Processed Crash Plates", AllReadyCrashPlates);
            }

            // add details of all cancelled crash plates to the relavant DS variable
            if (TotalCancelledCrashPlates > 0)
            {
                await context.AddOrUpdateGlobalVariableAsync("IOC Cancelled Crash Plates", AllCancelledCrashPlates);
            }

            Console.WriteLine($"***********  All sources for the order= {AllSources} Total sources found for the order {Totalsources} for order Id {RequestedOrder} " + Environment.NewLine);
            Console.WriteLine($"***********  All Processed sources for the order= {AllProcessedSources} Total processed sources for the order {TotalProcessedSources} for order Id {RequestedOrder} " + Environment.NewLine);

            Serilog.Log.Information("All sources for the order= {AllSources} Total sources found for the order {Totalsources}", AllSources.ToString(), Totalsources.ToString());
            Serilog.Log.Information("All queued sources for the order= {AllQueuedSources} Total Queued sources for the order {TotalQueuedsources}", AllQueuedSources.ToString(), TotalQueuedsources.ToString());
            Serilog.Log.Information("All Processed sources for the order= {AllProcessedSources} Total processed sources for the order{TotalProcessedSources}", AllProcessedSources.ToString(), TotalProcessedSources.ToString());
            Serilog.Log.Information("====$$$$$$$====");
            Serilog.Log.Information("All crash plates for the order= {AllCrashPlates} Total crash plates for the order {TotalCrashPlates}", AllCrashPlates.ToString(), TotalCrashPlates.ToString());
            Serilog.Log.Information("all queued crash plates for the order= {AllQueuedCrashPlates} Total Queued crash plates for the order{TotalQueuedCrashPlates}", AllQueuedCrashPlates.ToString(), TotalQueuedCrashPlates.ToString());
            Serilog.Log.Information("All processed crash plates for the order= {AllProcessedCrashPlates} Total processed crash plates for the order {TotalProcessedCrashPlates}", AllProcessedCrashPlates.ToString(), TotalProcessedCrashPlates.ToString());

        }

    }
}